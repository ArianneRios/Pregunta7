# -*- coding: utf-8 -*-
"""ejer7(b).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wYKGH9KC7JamFZbSu9YwnfurypetwFl2
"""

#para el inciso b de la 7

import random
import math

# Función de evaluación: f(x) = (x^(2x)) - 1
def eval_function(x):
    return (x ** (2 * x)) - 1

# Crear la población inicial (números enteros aleatorios entre 1 y 10)
def create_population(size=10):
    return [random.randint(1, 10) for _ in range(size)]

# Selección por torneo
def tournament_selection(population, fitnesses, k=3):
    selected = []
    for _ in range(len(population)):
        # Elegir k individuos aleatorios y seleccionar el mejor
        competitors = random.sample(list(zip(population, fitnesses)), k)
        selected.append(max(competitors, key=lambda ind: ind[1])[0])
    return selected

# Cruce de dos puntos
def crossover(parent1, parent2):
    mask = (1 << random.randint(0, 4)) - 1
    child1 = (parent1 & ~mask) | (parent2 & mask)
    child2 = (parent2 & ~mask) | (parent1 & mask)
    return child1, child2

# Mutación (voltear un bit aleatorio)
def mutate(individual, mutation_rate=0.1):
    if random.random() < mutation_rate:
        bit_to_flip = 1 << random.randint(0, 4)
        individual ^= bit_to_flip  # XOR voltea el bit seleccionado
    return individual

# Algoritmo genético manual
def genetic_algorithm(num_generations=3, population_size=10):
    population = create_population(population_size)

    # Evolución a lo largo de generaciones
    for generation in range(num_generations):
        print(f"Generación {generation + 1}")

        # Evaluar fitness de cada individuo
        fitnesses = [eval_function(ind) for ind in population]
        for ind, fit in zip(population, fitnesses):
            print(f"Individuo {ind}: f(x) = {fit}")

        # Selección
        selected_population = tournament_selection(population, fitnesses)

        # Cruce (por pares)
        offspring = []
        for i in range(0, len(selected_population), 2):
            if i + 1 < len(selected_population):
                child1, child2 = crossover(selected_population[i], selected_population[i + 1])
                offspring.append(child1)
                offspring.append(child2)
            else:
                offspring.append(selected_population[i])

        # Mutación
        population = [mutate(ind) for ind in offspring]

    # Retornar la población final
    return population

# Ejecutar el algoritmo manual
final_population_manual = genetic_algorithm()